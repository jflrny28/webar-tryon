<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>DIY Foot Try-On (TF.js + Three.js)</title>

<!-- ====== Three.js + GLTFLoader ====== -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

<!-- ====== TensorFlow.js + Pose Detection (BlazePose via MediaPipe) ====== -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@3.0.0/dist/pose-detection.min.js"></script>
<!-- MediaPipe (runtime files for BlazePose) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404"></script>

<style>
  html, body { margin:0; height:100%; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  /* Video behind, WebGL on top */
  #videoEl {
    position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover;
    transform: scaleX(-1);  /* mirror so it feels natural */
    z-index: 0;
  }
  #webgl { position: fixed; inset: 0; z-index: 1; pointer-events: none; }
  #ui { position: fixed; top: 10px; left: 10px; right: 10px; z-index: 2; display:flex; gap:8px; justify-content:space-between; }
  .btn { pointer-events:auto; padding:8px 12px; border-radius:10px; background:rgba(0,0,0,.55); color:#fff; border:1px solid rgba(255,255,255,.25); }
  #hud { position: fixed; left:0; right:0; bottom:14px; z-index:2; text-align:center; color:#fff; font-size:14px; text-shadow: 0 1px 2px rgba(0,0,0,.6); }
  #toast { position: fixed; top: 14px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.7); color:#fff; padding:8px 12px; border-radius:10px; z-index:3; display:none; }
  #loader { position: fixed; left:50%; top:50%; transform: translate(-50%, -50%); color:#fff; background: rgba(0,0,0,.6); padding:10px 14px; border-radius:10px; z-index:3; display:none; }
  /* gesture layer */
  #touchLayer { position:fixed; inset:0; z-index: 3; pointer-events:auto; }
</style>
</head>
<body>
<video id="videoEl" autoplay playsinline muted></video>
<canvas id="webgl"></canvas>

<div id="ui">
  <button class="btn" onclick="location.href='about:blank'">Close</button>
  <div style="display:flex; gap:8px;">
    <button class="btn" onclick="resetModel()">Reset</button>
    <button class="btn" onclick="toggleFoot()">Foot: <span id="footLabel">auto</span></button>
  </div>
</div>
<div id="hud">Move your phone so your feet are visible. Pinch to scale and twist to rotate. (Experimental)</div>
<div id="toast"></div>
<div id="loader">Loading model…</div>
<div id="touchLayer"></div>

<script>
(async function () {
  // ---------- Utilities ----------
  const $ = sel => document.querySelector(sel);
  const toast = (msg, ms=1800) => {
    const t = $('#toast'); t.textContent = msg; t.style.display = 'block';
    clearTimeout(window.__toastTimer);
    window.__toastTimer = setTimeout(()=> t.style.display = 'none', ms);
  };

  // Model URL from ?model=
  const params = new URLSearchParams(location.search);
  const MODEL_URL = params.get('model') ||
    'https://firebasestorage.googleapis.com/v0/b/trial-50e43.firebasestorage.app/o/models%2Fshoe_1757851728914.glb?alt=media&token=f384d0bb-91c2-4d07-ac36-354e51db46f1';

  // ---------- Camera ----------
  const video = $('#videoEl');
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
  } catch (e) {
    alert('Camera permission needed. Open over HTTPS and allow camera.');
    throw e;
  }

  // ---------- Three.js ----------
  const renderer = new THREE.WebGLRenderer({ canvas: $('#webgl'), alpha: true, antialias: true });
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.01, 100);
  camera.position.set(0, 0, 2.2); // fixed Z; we’ll fake scale
  renderer.setSize(innerWidth, innerHeight);
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.75));
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(0.5, 1, 1);
  scene.add(dir);

  // Shoe holder
  const holder = new THREE.Group();
  scene.add(holder);

  // Load GLB
  $('#loader').style.display = 'block';
  const loader = new THREE.GLTFLoader();
  let shoe;
  try {
    const gltf = await loader.loadAsync(MODEL_URL);
    shoe = gltf.scene;
    // Initial orientation: most shoes are Z-forward; rotate so top faces camera
    shoe.rotation.set(-Math.PI/2, 0, 0);
    shoe.scale.set(0.35, 0.35, 0.35); // starting guess; will be scaled dynamically
    holder.add(shoe);
    $('#loader').style.display = 'none';
    toast('Model loaded');
  } catch (e) {
    $('#loader').style.display = 'none';
    console.error(e);
    toast('Failed to load model');
  }

  // ---------- Pose Detector (BlazePose, mediapipe runtime) ----------
  const detector = await poseDetection.createDetector(
    poseDetection.SupportedModels.BlazePose,
    {
      runtime: 'mediapipe',
      modelType: 'full',
      solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/pose'
    }
  );

  // Helper: pick best visible foot landmarks
  let forceFoot = 'auto'; // 'left' | 'right' | 'auto'
  function chooseFoot(kps) {
    const lAnk = kps.find(k => k.name === 'left_ankle');
    const rAnk = kps.find(k => k.name === 'right_ankle');
    const lToe = kps.find(k => k.name === 'left_foot_index');
    const rToe = kps.find(k => k.name === 'right_foot_index');
    const lKnee = kps.find(k => k.name === 'left_knee');
    const rKnee = kps.find(k => k.name === 'right_knee');

    if (forceFoot === 'left') return {ank:lAnk, toe:lToe, knee:lKnee};
    if (forceFoot === 'right') return {ank:rAnk, toe:rToe, knee:rKnee};

    // auto: pick the side with higher visibility
    const lVis = ((lAnk?.score||0)+(lToe?.score||0))/2;
    const rVis = ((rAnk?.score||0)+(rToe?.score||0))/2;
    return (rVis>lVis) ? {ank:rAnk, toe:rToe, knee:rKnee} : {ank:lAnk, toe:lToe, knee:lKnee};
  }

  // Gesture controls (pinch scale, twist rotate)
  let gestureStart = null;
  const touchLayer = $('#touchLayer');
  touchLayer.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const [a,b] = e.touches;
      gestureStart = {
        d: Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY),
        a: Math.atan2(b.clientY - a.clientY, b.clientX - a.clientX),
        scale: holder.scale.x,
        rotY: holder.rotation.y
      };
    }
  }, {passive:false});
  touchLayer.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2 && gestureStart) {
      e.preventDefault();
      const [a,b] = e.touches;
      const d = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
      const a2 = Math.atan2(b.clientY - a.clientY, b.clientX - a.clientX);
      const s = Math.min(3, Math.max(0.15, gestureStart.scale * (d / gestureStart.d)));
      holder.scale.set(s,s,s);
      holder.rotation.y = gestureStart.rotY + (a2 - gestureStart.a);
    }
  }, {passive:false});
  touchLayer.addEventListener('touchend', () => gestureStart = null, {passive:true});

  // Smoothing helpers
  const smooth = (curr, target, alpha) => curr + (target - curr) * alpha;
  let smX=0, smY=0, smRot=0, smScale=0.35;

  // Main loop
  async function tick() {
    // Run pose every N frames to save CPU
    let poses = [];
    try {
      poses = await detector.estimatePoses(video, { flipHorizontal: true });
    } catch (e) {
      // ignore transient errors
    }

    if (poses[0]?.keypoints) {
      const {ank, toe, knee} = chooseFoot(poses[0].keypoints);
      if (ank && toe && knee && ank.score>0.3 && toe.score>0.3) {
        // 2D coordinates normalized [0..videoWidth/Height]
        const vw = video.videoWidth || innerWidth;
        const vh = video.videoHeight || innerHeight;

        // center between ankle & toe (rough foot center)
        const cx = (ank.x + toe.x) / 2;
        const cy = (ank.y + toe.y) / 2;

        // angle in screen plane (x right, y down) -> convert to Y rotation
        const angle = Math.atan2(toe.y - ank.y, toe.x - ank.x);

        // crude depth/scale proxy: knee-ankle distance in pixels
        const leg = Math.hypot((knee?.x||ank.x) - ank.x, (knee?.y||ank.y) - ank.y); // px
        // map leg px to scale (tune constants for your device)
        const targetScale = Math.min(1.8, Math.max(0.18, 140 / (leg+1)));

        // map 2D screen to [-1..1] then to camera plane @ fixed Z
        const nx = (cx / vw) * 2 - 1;
        const ny = -((cy / vh) * 2 - 1);

        // place holder in front of camera; convert NDC to world at z≈0
        // simple approach: position in camera space using tangent of FOV
        const z = 0; // near the origin; camera is at z=2.2
        const vFov = THREE.MathUtils.degToRad(camera.fov);
        const h = Math.tan(vFov/2) * Math.abs(camera.position.z - z) * 2;
        const w = h * camera.aspect;
        const targetX = nx * (w/2);
        const targetY = ny * (h/2);

        // smooth & apply
        smX = smooth(smX, targetX, 0.35);
        smY = smooth(smY, targetY - 0.05, 0.35); // slight offset down
        smRot = smooth(smRot, -angle + Math.PI/2, 0.25); // heuristic
        smScale = smooth(smScale, targetScale, 0.25);

        holder.position.set(smX, smY, 0);
        holder.rotation.set(-Math.PI/2, smRot, 0);
        holder.scale.set(smScale, smScale, smScale);
      }
    }

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  tick();

  // UI helpers
  window.resetModel = () => {
    holder.position.set(0,0,0);
    holder.rotation.set(-Math.PI/2, 0, 0);
    holder.scale.set(0.35,0.35,0.35);
    toast('Model reset');
  };
  window.toggleFoot = () => {
    forceFoot = (forceFoot === 'auto') ? 'left' : (forceFoot === 'left' ? 'right' : 'auto');
    $('#footLabel').textContent = forceFoot;
  };
})();
</script>
</body>
</html>
